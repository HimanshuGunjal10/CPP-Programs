Do not use printf, instead use uart0_puts() function from #include "uart0_min.h"
because uart0_puts() is not interrupt driven, and uses a polled version of the char output driver
FreeRTOS and stdio printf is pre-configured to use uart0_min.h before main() enters.
uart0_puts("aaaaaaaaaaaaaaaaaaaa");

The main() creates tasks or "threads". 
 (main)
 	xTaskCreate (int_led, "int_led", 1024, NULL, PRIORITY_LOW,NULL);
 (code)
void int_led(void *pvParameter)
{
	objects
	declarations
	while(1)
	{
		...code
		vTaskDelay(500);
	}
}

Creating Tasks:
 BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
                         const char * const pcName,
                         configSTACK_DEPTH_TYPE usStackDepth,
                         void *pvParameters,
                         UBaseType_t uxPriority,
                         TaskHandle_t *pxCreatedTask
                       );
                       
                       //xTaskCreate(fn,name,size,parameters,priority,handle)

RAM is required to hold a task's state. Defined in the size/depth
If a task is created using xTaskCreate() then the required RAM is automatically allocated from the FreeRTOS heap.(****)
If a task is created using xTaskCreateStatic() then the RAM is provided by the application writer, so can be statically allocated at compile time.

***: https://www.freertos.org/a00125.html
Following notes are from this article.

pvTaskCode	- pointer to the task code. Tasks are infinite loops. should NOT return anything. Though they can delete themselves
pcName		- name for task
usStackDepth- #words (not bytes) for e.g. if stack is 16 bits wide = 16/8 = 2 word wide. and usStackDepth = 100, then 200 bytes will be allocated
pvParameters- any parameter to be passed. Note:if pvParameter is an address of a variable, then that address must still exist when the task executes.So, CANT use stack variables(****)
uxPriority	- priority of the task
pxCreatedTask- handle, optional


code:
BaseType_t xReturned;
TaskHandle_t xHandle = NULL;

    /* Create the task, storing the handle. */
    xReturned = xTaskCreate(
                    vTaskCode,       /* Function that implements the task. */
                    "NAME",          /* Text name for the task. */
                    STACK_SIZE,      /* Stack size in words, not bytes. */
                    ( void * ) 1,    /* Parameter passed into the task. */
                    tskIDLE_PRIORITY,/* Priority at which the task is created. */
                    &xHandle );      /* Used to pass out the created task's handle. */

    if( xReturned == pdPASS )
    {
        /* The task was created.  Use the task's handle to delete the task. */
        vTaskDelete( xHandle );(****)
    }

--
Stack size:
Exactly as when writing a bare metal application, the amount of stack required is dependent on the following application specific parameters:

The function call nesting depth
The number and size of function scope variable declarations
The number of function parameters
The processor architecture
The compiler
The compiler optimisation level
The stack requirements of interrupt service routines - which for many RTOS ports is zero as the RTOS will switch to use a dedicated interrupt stack on entry to an interrupt service routine.

uxTaskGetStackHighWaterMark() API function can be used to see how much stack has actually been used, 

--