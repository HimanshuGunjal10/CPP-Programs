
SPI - Serial & Peripheral Interface
	full speed (24Mhz is the usual maximum for SCLK)
	full duplex
	3 wires (MISO,MOSI,SCLK) [Note: master-slave connections: MISO-SO, MOSI-SI, SCLK-SCLK] alos SS-SS (so 4 wires, SS wires increase for increase in slaves)
	master/slave (CS) (set high when master needs to select a slave. Rest all are high impedance)

As a warning, if your firmware selects more than one SPI slave chip select, and they both attempt to drive the MISO line, since those lines are totem-pole (push-pull), there will be bus contention and could possibly destroy both SPI devices. (****)

For a whole transaction to be qualified, the ~CS  must be asserted. 

Cons:
	Although the communication protocol can allow for full duplex communication, the only way for a slave device to be able to communicate with the master is if the master initiates communication. (****)
	IO pin count increases if we need to add more slave devices on the network
--
SSP stands for Synchronous Serial Protocol.
SPI is one of the synchronous serial protocols it can perform.

--
If two CS signals are asserted at the same time, hardware damage will occur. (****)
So, how do we make 2 tasks working on different devices communicate?
	soln- Mutex

--

PRIORITY INVERSION
The OS tick event occurs, a middle priority task, that never sleeps is ready to run, it begins to run, high priority task is blocked on semaphore and low priority task is blocked by the middle priority task. This is priority inversion, where a medium priority task is running over a higher priority task.

Solution - Mutex
Low priority task inherits the highest priority of the task that attempts to take the mutex it posses.
Low priority task gives the mutex, low priority task de-inheritates its priority, and the high task immediately begins to run. It will run over the medium task.

--
Mutex = priority token
Same as Semaphore, but because of the priority inversion functionality can be more efficient

//main
	SemaphoreHandle_t m = xSemaphoreCreateMutex();

//defn
	void task_one(void *pV)
	{
		if(xSemaphoreGet(m,1000))
		{
			//do C.S...
			xSemaphoreGive(m);	//***
		}
	}

	void task_two(void *pV)
	{
		if(xSemaphoreGet(m,1000))
		{
			//do C.S...
			xSemaphoreGive(m);	//***
		}
	}


-------
DRIVER
-------


bool LabSpi::initialize(uint8_t data_size_select, FrameModes format, uint8_t divide)
{
    LPC_SC->PCONP |= (1<<10);
    LPC_SC->PCLKSEL0 &= ~(0x3<<20);
    LPC_SC->PCLKSEL0 |= (0x3<<20);

    if (divide%2 != 0)
    {
        return false;
    }
    else
    {
        LPC_SSP0->CPSR = divide;
        //LPC_PINCON->PINSEL0 &= ~(0x3<<13);
        LPC_PINCON->PINSEL0 |= (0x2A<<14);
        //LPC_PINCON->PINMOD
        LPC_SSP1->CR0 &= ~(0xF<<4);
        LPC_SSP1->CR0 |= (data_size_select);
        LPC_SSP1->CR1 |= (1<<1);
        LPC_GPIO0->FIODIR |= (1<<6);
        return true;
    }
}

uint32_t LabSpi::transfer(uint8_t send)
{
    LPC_SSP1->DR = send;
    while (LPC_SSP1->SR & (1<<4));
    return LPC_SSP1->DR;
}