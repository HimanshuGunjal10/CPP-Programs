Lookup tables are static arrays that sacrifices memory storage in place of a simple array index lookup of precalculated values.
i.e eat up memory for speed. code more readable and easier to maintain

//without lookup - calculation each time
	double calculateADCtoDegrees(uint8_t adc)
	{
		return ((double)(adc)*(270/256));
	}

//with lookup - data fetch mechanism for pre loaded values
	const double potAngle[256]	//256 adc values preloaded in their degree convertions
	{
		[0] = 0.0;
		[1] = 1.2;
		...
		[255] = 270;
	}


NVIC
Nested Vector Interrupt Controller

An interrupt is the "hardware capability" of a CPU to break the normal flow of software to attend an urgent request.

On an interrupts - tasks
	h/w interrupt - interrupts CPU
	CPU core jumps to the corresponding ISR (by changing SP)
	disable interrupts of that/lower priority
	push registers into stack
	change SP
	run ISR
	pop registers(restore)
	re-enable interrupts

Note: higher priority interrupt can interrupt another interrupt (NESTED)


SJOne board
NVIC_EnableIRQ(EINT3_IRQn);
Run this function to allow the NVIC to accept a particular interrupt request.
Where the input is the IRQ number. This can be found in the LCP17xx.h file. Search for enum IRQn.
All you need to do is specify the IRQ number and the function you want to act as an ISR. This will then swap out the previous ISR with your function.

//code
	void myEINT3ISR_funcName(void)
	{
	    doSomething();
	    clearInterruptFlag();
	}

	int main()
	{
	    isr_register(EINT3_IRQn, myEINT3ISR_funcName);
	    NVIC_EnableIRQ(EINT3_IRQn);
	}

CONS: must wait until main is called to activate the system accepting interrupts

--
Inside an ISR
	Do as little as possible
	Do not poll
	Clear sourse of the interrput (e.g a flag or a variable causing the interrupt so that you don't re-enter the ISR, an infinite loop)
	Use binarySemaphore in an ISR (give the semaphore and check it in another function that services the ISR)