Embedded C Questions

Volatile - its a qualifier to tell compiler not to optimize that variable. It might be getting updated somewhere else.(outside the scope of that program)
	useful for memory mapped peripheral registers, global variables changed by an ISR, or in multiple tasks in a multi threaded aplication.
	Rather than optimizing that variable, we want the compiler to load the variable every time it is encountered. If we declare a variable volatile, compiler will not cache it in its register.

const + volatile?
	yes. const restricts change in that program. But the variable can change from somewhere else. So, yes it is a possibility.

volatile int* p - means the pointer is not volatile but the integer it is pointing to is.

If we don't use null pointer, then we can't "verify" whether this pointer points to any valid location or not.

Void pointer - genereic pointer means that it points to a variable that can be of any type. 
	We can pass any kind of pointer and reference it as a void pointer. But to dereference it, we have to typecast the void pointer to correct data type.

ISR does not return anything. An ISR returns nothing because there is no caller in the code to read the returned values.

printf inside an ISR
	Printf function in ISR is not supported because printf function is not reentrant, thread safe and uses dynamic memory allocation which takes a lot of time and can affect the speed of an ISR up to a great extent.

	To debug ISR, definitive logs are better. Breakpoints may lead to wrong functionality.

Static variable
	If declared in a header file, then each source file that includes the header file will have its own copy of the variable so not recommended.
	Static variables also cannot be declared without defining it.

Inline function
	These functions have a small definition and the function body is substituted in each call to the inline function. The argument passing and stack maintenance is skipped and it results in faster code execution, but it increases code size.

header files data is stored in stack memory

static 
	1. A variable declared static within a function maintains its value between calls to that function.
	2. A variable declared as static within a file, scope of that variable will be within that file, but it can't be accessed by other files.
	3. Functions declared static within a module can be accessed by other functions within that module. That is, the scope of the function is localized to the module within which it is declared.

RISC
	small precise instructions - less transistors to implement - speed - less power - emphasis on s/w rather than h/w

Hard RTOS - If the system fails to meet the deadline, even once, the system is considered to have failed. 
Soft RTOS - its acceptable

IPC - pipes, named pipes, semaphores, shared memory, msg queue, socket.

Semaphore is actually a variable or abstract data type which controls access to a common resource by multiple processes.
	Binary semaphore – It can have only two values (0 and 1). The semaphore value is set to 1 by the process in charge, when the resource is available.
	Counting semaphore – It can have value greater than one. It is used to control access to a pool of resources.

Spin lock
	A thread waiting on a resource may loop and check the resource without doing any useful work.

Difference - semaphore vs mutex
Mutual exclusion and synchronization can be used by binary semaphore while mutex is used only for mutual exclusion.
A mutex can be released by the same thread which acquired it. Semaphore values can be changed by other thread also.
From an ISR, a mutex can not be used.
The advantage of semaphores is that, they can be used to synchronize two unrelated processes trying to access the same resource.
Semaphores can act as mutex, but the opposite is not possible.

Virtual memory can be implemented using paging.
When a process is to be swapped in, the pager guesses which pages will be used based on some algorithm, before the process is swapped out again. Instead of swapping whole process, the pager brings only the necessary pages into memory. By that way, it avoids reading in unnecessary memory pages, decreasing the swap time and the amount of physical memory.

Declare a manifest constant that returns the number of seconds in a year using preprocessor? Disregard leap years in your answer.
	#define SECONDS_IN_YEAR (60UL * 60UL * 24UL * 365UL)
	Do not forget to use UL, since the output will be very big integer.

The preprocessor commands are processed and expanded by the preprocessor before actual compilation. After preprocessing, the compiler takes the output of the preprocessor and the source code, and generates assembly code. Once compiler completes its work, the assembler takes the assembly code and produces an assembly listing with offsets and generate object files.
The linker combines object files or libraries and produces a single executable file. It also resolves references to external symbols, assigns final addresses to functions and variables, and revises code and data to reflect new addresses.

In static linking, all the library modules used in the program are placed in the final executable file making it larger in size
In case of dynamic linking, only the names of the module used are present in the executable file and the actual linking is done at run time when the program and the library modules both are present in the memory.

In case of dynamic linking, only the names of the module used are present in the executable file and the actual linking is done at run time when the program and the library modules both are present in the memory.
	volatile int *ptr; //means the vaue pointed can change
	ptr = (int *)0x67a9; 
	*ptr = 0xaa55;

	//amazon
	if(*ptr != saved_value)
		do something;
		saved_value = *ptr;

Write down the equivalent pointer expression for referring the same element a[i][j][k][l] ?
a[i][j][k][l] == *(*(*(*(a+i)+j)+k)+l)

 int const * p = 5;
 printf("%d",++(*p));
 The above program will result in compilation error stating “Cannot modify a constant value”. Here p is a pointer to a constant integer. But in the next statement, we are trying to modify the value of that constant integer. It is not permissible in C and that is why it will give a compilation error.


 unsigned int a = 2;
 int b = -10;
 (a + b > 0)?puts("greater than 0"):puts("less than 1");
 Here the addition is between different integral types - one is unsigned int and another is int. So, all the operands in this addition are promoted to unsigned integer type and b turns to a positive number and eventually a big one. 


Write a code fragment to set only bit 3 of an integer.
 #define BIT(n) (0x1 << n)
int a;
void SetBit3()
{
   a |= BIT(3);
}

--
We can use function inside ISR as long as that function is not invoked from other portion of the code.

Printf function in ISR is not supported because printf function is not reentrant, thread safe and uses dynamic memory allocation which takes a lot of time and can affect the speed of an ISR up to a great extent.

Putting a break point inside ISR is not a good idea because debugging will take some time and a difference of half or more second will lead to different behavior of hardware. To debug ISR, definitive logs are better.

A static variable cannot be declared without defining it.

Include files can be nested any number of times. But you have to make sure that you are not including the same file twice.

RTOS uses pre-emptive scheduling. In pre-emptive scheduling, the higher priority task can interrupt a running process and the interrupted process will be resumed later.

Mutual exclusion and synchronization can be used by binary semaphore while mutex is used only for mutual exclusion.
A mutex can be released by the same thread which acquired it. Semaphore values can be changed by other thread also.
From an ISR, a mutex can not be used.
The advantage of semaphores is that, they can be used to synchronize two unrelated processes trying to access the same resource.
Semaphores can act as mutex, but the opposite is not possible.

Paging is a memory management scheme by which computers can store and retrieve data from the secondary memory storage when needed in to primary memory

Passing structure by its value to a function is possible, but not a good programming practice.

---
It’s preferable to use static memory allocation on platforms with memory sizes in the low kilobytes and below. This is because data overhead, CPU overhead, and memory fragmentation can be significant issues when using dynamic memory allocation.

The microcontroller is a self-contained system with peripherals, memory and a processor that can be used as embedded system.

The volatile keyword is mainly used where we directly deal with GPIO, interrupt or fag Regiser. It
is also used where a global variable or bufer is shared between the threads.

const, volatile, long etc are type qualifiers

volatile int *const ptr;
-
#define FLAG_REG 0xAABBCCDD

volatile uint32_t* const ptr = (uint32_t*)FLAG_REG;

An ISR is called when a hardware or software event occurs, it is not called by the code, so that’s the reason no parameters are passed into an ISR and nor is anything returned from it.

Yes, you can call a function(provided its an re-entrant function) within the ISR but it is not recommended because it can increase the interrupt latency and decrease the performance of the system.

startup code is writtern in assembly language and does the following steps:
Disable all interrupts.
Copy any initialized data from ROM to RAM.
Zero the uninitialized data area.
Allocate space for and initialize the stack.
Initialize the processor’s stack pointer.
Create and initialize the heap.
Enable interrupts.
Call main.

-
Bit rate is the number of bits per second. It determines the number of bits traveled per second.	
This term generally used to describe the processor efficiency.

Baud rate is the number of signal units per second. It determines how many times the state of a signal is changing. 
It can determine how much bandwidth is required to send the signal.
This term generally used to describe the data transmission over the channel.

Bit rate = baud rate x the number of bits per signal unit

The Bus error issue occurs when a program tries to access an invalid memory or unaligned memory. The bus error comes rarely as compared to the segmentation fault.
Some scenarios where SIGBUS signal is generated.
Non-existent address.
Unaligned access.
Paging errors

const is scoped by C block, #define applies to a file.
since macro is pre-processed, there is no type checking

Structure padding increases the performance of the processor at the penalty of memory

What is the return value of malloc (0)?
If the size of the requested space is zero, the behavior will be implementation-defined. Dont use this

the free function gets the bookkeeping information and release the allocated memory. 

function pointers are used in the implementation of the callback function, finite state machine and to provide the feature of polymorphism in C language
void (*fun_ptr)(int) = &fun; 

power of 2?
return (!num && !(num & num-1));	//note: num should be unsigned i.e positive

00001110 = 14

Using the void pointer we can create a generic function that can take arguments of any data type

A static global variable      ===>>>  internal linkage.
A non-static global variable  ===>>>  external linkage.
So global variable can be accessed outside of the file but the static global variable only accesses within the file in which it is declared.


---Extra, in-depth
Read below from the link: https://aticleworld.com/embedded-c-interview-questions-2/

What is the difference between I2c and SPI communication Protocol?
What is the difference between RS232 and RS485?
What is the difference between Bit Rate and Baud Rate?
What are the common causes of segmentation fault in C?
What is the difference between a macro and a function?
How to convert little endian to big endian vice versa in C?
Here, I have mentioned some more embedded c interview questions for you.
